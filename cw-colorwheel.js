// Generated by CoffeeScript 1.3.1
(function() {
  var $, asPercentage, circleWrap, cw, toDegrees, toRadians, __noConflict,
    _this = this,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  cw = {};

  __noConflict = this.cw;

  this.cw = cw;

  cw.noConflict = function() {
    _this.cw = __noConflict;
    return cw;
  };

  cw.Color = (function() {

    Color.name = 'Color';

    function Color() {
      this.isColor = true;
    }

    return Color;

  })();

  cw.RGB = (function(_super) {

    __extends(RGB, _super);

    RGB.name = 'RGB';

    function RGB(r, g, b) {
      this.r = r;
      this.g = g;
      this.b = b;
      RGB.__super__.constructor.apply(this, arguments);
    }

    RGB.prototype.isTransparent = function() {
      return !((this.r != null) || (this.g != null) || (this.b != null));
    };

    RGB.prototype.toRGB = function() {
      return new cw.RGB(this.r, this.g, this.b);
    };

    RGB.prototype.toHSL = function() {
      var chroma, h, l, max, min, s;
      if (this.isTransparent()) {
        return new cw.HSL();
      }
      max = Math.max(this.r, this.g, this.b);
      min = Math.min(this.r, this.g, this.b);
      chroma = max - min;
      if (chroma === 0) {
        return new cw.HSL(void 0, void 0, max);
      } else {
        h = 60 * (function() {
          switch (max) {
            case this.r:
              return (this.g - this.b) / chroma % 6;
            case this.g:
              return (this.b - this.r) / chroma + 2;
            case this.b:
              return (this.r - this.g) / chroma + 4;
          }
        }).call(this);
        l = (max + min) / 2;
        s = chroma / (1 - Math.abs(2 * l - 1));
        return new cw.HSL(h, s, l);
      }
    };

    RGB.prototype.to24Bit = function() {
      return {
        r: Math.round(this.r * 255),
        g: Math.round(this.g * 255),
        b: Math.round(this.b * 255)
      };
    };

    RGB.prototype.toString = function() {
      var b, g, r, toByte, _ref;
      if (this.isTransparent()) {
        return 'transparent';
      } else {
        _ref = this.to24Bit(), r = _ref.r, g = _ref.g, b = _ref.b;
        toByte = function(value) {
          return ('0' + value.toString(16)).slice(-2);
        };
        return "#" + (toByte(r)) + (toByte(g)) + (toByte(b));
      }
    };

    RGB.fromString = function(string) {
      var f;
      if (string.toLowerCase() === 'transparent') {
        return new cw.RGB();
      } else {
        switch (string.length) {
          case 7:
            f = function(i) {
              return parseInt(string.substring(i * 2 + 1, i * 2 + 3), 16) / 255;
            };
            break;
          case 4:
            f = function(i) {
              return parseInt(string.charAt(i + 1), 16) / 15;
            };
            break;
          default:
            throw new Error("CSS color '" + string + "' not valid");
        }
        return new cw.RGB(f(0), f(1), f(2));
      }
    };

    return RGB;

  })(cw.Color);

  cw.HSL = (function(_super) {

    __extends(HSL, _super);

    HSL.name = 'HSL';

    function HSL(h, s, l) {
      this.h = h;
      this.s = s;
      this.l = l;
      HSL.__super__.constructor.apply(this, arguments);
    }

    HSL.prototype.isPartial = function() {
      return !((this.h != null) && (this.s != null) && (this.l != null));
    };

    HSL.prototype.isTransparent = function() {
      return !((this.h != null) || (this.s != null) || (this.l != null));
    };

    HSL.prototype.toHSL = function() {
      return new cw.HSL(this.h, this.s, this.l);
    };

    HSL.prototype.toRGB = function() {
      var b, chroma, g, h, l, mid, min, r, s, _ref, _ref1, _ref2;
      if (this.isTransparent()) {
        return new cw.RGB();
      }
      h = this.h / 60;
      s = (_ref = this.s) != null ? _ref : 1;
      l = (_ref1 = this.l) != null ? _ref1 : 0.5;
      chroma = (1 - Math.abs(2 * l - 1)) * s;
      min = l - chroma / 2;
      mid = chroma * (1 - Math.abs(h % 2 - 1));
      if (isNaN(h)) {
        return new cw.RGB(l, l, l);
      } else {
        _ref2 = (function() {
          switch (Math.floor(h)) {
            case 0:
              return [chroma, mid, 0];
            case 1:
              return [mid, chroma, 0];
            case 2:
              return [0, chroma, mid];
            case 3:
              return [0, mid, chroma];
            case 4:
              return [mid, 0, chroma];
            case 5:
              return [chroma, 0, mid];
          }
        })(), r = _ref2[0], g = _ref2[1], b = _ref2[2];
        return new cw.RGB(r + min, g + min, b + min);
      }
    };

    HSL.prototype.toString = function() {
      return this.toRGB().toString();
    };

    HSL.fromString = function(string) {
      return cw.RGB.fromString(string).toHSL();
    };

    return HSL;

  })(cw.Color);

  toDegrees = function(radians) {
    return radians * 180 / Math.PI;
  };

  toRadians = function(degrees) {
    return degrees * Math.PI / 180;
  };

  asPercentage = function(n) {
    return Math.max(0, Math.min(1, n));
  };

  circleWrap = function(position) {
    return (position + 360) % 360;
  };

  cw.ColorWheel = (function() {

    ColorWheel.name = 'ColorWheel';

    function ColorWheel(options) {
      this._onDocumentDrag = __bind(this._onDocumentDrag, this);

      this._onDocumentMouseUp = __bind(this._onDocumentMouseUp, this);

      this._onMouseDown = __bind(this._onMouseDown, this);

      this._onSLMouseDown = __bind(this._onSLMouseDown, this);

      this._onHueMouseDown = __bind(this._onHueMouseDown, this);

      this.hintSL = __bind(this.hintSL, this);

      var _ref;
      this.options = $.extend({
        callback: null,
        defaultColor: new cw.HSL(),
        inset: 10,
        allowPartialSelection: true,
        allowHueSelection: true,
        allowSLSelection: true,
        SLHiddenWhenNoHue: true,
        animationTime: 200,
        hintEnable: false,
        hintQueue: 'hint.cw',
        hintTime: 500
      }, options);
      this._hsl = ((_ref = this.options.defaultColor) != null ? _ref.isColor : void 0) ? this.options.defaultColor.toHSL() : cw.HSL.fromString(this.options.defaultColor);
      this._selected = 'none';
      this.$root = $('<div class="cw-colorwheel" />');
      this.$hue = $('<div class="cw-h" />').appendTo(this.$root);
      this.$sl = $('<div class="cw-sl" />').appendTo(this.$root);
      this.swatches = {
        $hue: $('<div class="cw-swatch" />').appendTo(this.$hue),
        $sl: $('<div class="cw-swatch" />').appendTo(this.$sl)
      };
      this.markers = {
        $hue: $('<div class="cw-marker" />').appendTo(this.$hue),
        $sl: $('<div class="cw-marker" />').appendTo(this.$sl)
      };
      this.redraw();
      this.$root.bind('mousedown.cw', this._onMouseDown);
      this.$hue.bind('mousedown.cw', this._onHueMouseDown);
      this.$sl.bind('mousedown.cw', this._onSLMouseDown);
    }

    ColorWheel.prototype.hintSL = function(onOrOff) {
      var animOptions, cssBoxShadow,
        _this = this;
      if (onOrOff == null) {
        onOrOff = true;
      }
      if (!this.options.hintEnable) {
        return;
      }
      animOptions = {
        queue: this.options.hintQueue,
        duration: this.options.hintTime
      };
      cssBoxShadow = function(blur, alpha) {
        var b, g, r, _ref;
        _ref = (new cw.HSL(_this._hsl.h, 1, .5)).toRGB().to24Bit(), r = _ref.r, g = _ref.g, b = _ref.b;
        return {
          boxShadow: "0 0 " + blur + "px rgba(" + r + "," + g + "," + b + "," + alpha + ")"
        };
      };
      this.$sl.stop(this.options.hintQueue, true);
      if (onOrOff === true) {
        return (function() {
          return _this.$sl.animate(cssBoxShadow(20, 1), animOptions).animate(cssBoxShadow(15, .5), animOptions).queue(_this.options.hintQueue, arguments.callee).dequeue(_this.options.hintQueue);
        })();
      } else {
        return this.$sl.animate(cssBoxShadow(5, 0), animOptions).dequeue(this.options.hintQueue);
      }
    };

    ColorWheel.prototype.getHSL = function() {
      return this._hsl.toHSL();
    };

    ColorWheel.prototype.setHSL = function(hsl) {
      if (!this.options.allowPartialSelection) {
        if (hsl.isPartial()) {
          throw new Error("Setting partial HSL object when allowPartialSelection:false");
        }
      }
      this._hsl = hsl;
      this.redraw();
      return this.$root.trigger('change', [this.getHSL(), this]);
    };

    ColorWheel.prototype.isHueSelected = function() {
      return this._hsl.h != null;
    };

    ColorWheel.prototype.isSLSelected = function() {
      return (this._hsl.s != null) || (this._hsl.l != null);
    };

    ColorWheel.prototype.canSetHue = function() {
      return this.options.allowHueSelection;
    };

    ColorWheel.prototype.canSetSL = function() {
      return this.options.allowSLSelection && (!this.canSetHue() || !this.options.allowPartialSelection || !this.options.SLHiddenWhenNoHue || this.isHueSelected());
    };

    ColorWheel.prototype._onHueMouseDown = function() {
      if (this.canSetHue()) {
        return this._selected = 'ring';
      }
    };

    ColorWheel.prototype._onSLMouseDown = function() {
      if (this.canSetSL()) {
        return this._selected = 'box';
      }
    };

    ColorWheel.prototype._onMouseDown = function(e) {
      if (this._selected !== 'none') {
        $(document).bind('mousemove.cw', this._onDocumentDrag).bind('mouseup.cw', this._onDocumentMouseUp);
        this._onDocumentDrag(e);
      }
      return e.preventDefault();
    };

    ColorWheel.prototype._onDocumentMouseUp = function(e) {
      $(document).unbind('mousemove.cw').unbind('mouseup.cw');
      this._selected = 'none';
      return e.preventDefault();
    };

    ColorWheel.prototype._onDocumentDrag = function(e) {
      var h, l, response, s, x, y;
      x = e.pageX - this.$root.offset().left - this.$root.width() / 2;
      y = e.pageY - this.$root.offset().top - this.$root.height() / 2;
      h = this._hsl.h;
      s = this._hsl.s;
      l = this._hsl.l;
      switch (this._selected) {
        case 'ring':
          h = circleWrap(toDegrees(Math.atan2(x, -y)));
          break;
        case 'box':
          s = asPercentage(.5 - x / this.$sl.width());
          l = asPercentage(.5 - y / this.$sl.height());
      }
      if (this.options.callback != null) {
        response = $.proxy(this.options.callback, this, new cw.HSL(h, s, l))();
      }
      if (response !== false) {
        if (response != null ? response.isColor : void 0) {
          this.setHSL(response.toHSL());
        } else {
          this.setHSL(new cw.HSL(h, s, l));
        }
      }
      return e.preventDefault();
    };

    ColorWheel.prototype.redraw = function() {
      var innerRadius, outerRadius, position, _ref, _ref1;
      this.$hue.toggle(this.canSetHue());
      if (this.isHueSelected()) {
        outerRadius = this.$hue.width() / 2;
        innerRadius = outerRadius - this.options.inset;
        position = {
          top: Math.round((-Math.cos(toRadians(this._hsl.h)) * innerRadius) + outerRadius),
          left: Math.round((Math.sin(toRadians(this._hsl.h)) * innerRadius) + outerRadius)
        };
        this.swatches.$hue.css('background-color', new cw.HSL(this._hsl.h, 1, .5)).add(this.markers.$hue).css(position).show();
      } else {
        this.swatches.$hue.hide();
        this.markers.$hue.hide();
      }
      if (this.canSetSL()) {
        this.$sl.css('background-color', new cw.HSL(this._hsl.h, 1, .5)).fadeIn(this.options.animationTime);
      } else {
        this.$sl.hide();
      }
      if (this.isSLSelected() || this.hasBeenSet) {
        position = {
          top: Math.round(this.$sl.height() * (1 - ((_ref = this._hsl.l) != null ? _ref : 0.5))),
          left: Math.round(this.$sl.width() * (1 - ((_ref1 = this._hsl.s) != null ? _ref1 : 1)))
        };
        this.swatches.$sl.css('background-color', this._hsl).add(this.markers.$sl).css(position).show();
      } else {
        this.swatches.$sl.hide();
        this.markers.$sl.hide();
      }
      return this.hintSL(this.canSetSL() && !this.isSLSelected());
    };

    return ColorWheel;

  })();

  $ = {};

  cw.jQuery = function(jQuery) {
    $ = jQuery;
    $.expr[':']['color-wheel'] = function(el) {
      return el.colorWheel != null;
    };
    return $.fn.colorWheel = function(options) {
      var node, _i, _len;
      for (_i = 0, _len = this.length; _i < _len; _i++) {
        node = this[_i];
        if (!(!(node.colorWheel != null))) {
          continue;
        }
        node.colorWheel = new cw.ColorWheel(options);
        $(node).append(node.colorWheel.$root);
      }
      return this;
    };
  };

  cw.jQuery(this.jQuery);

}).call(this);
